/*
 * To change this template, choose Tools | Templates
 * and open the template in the editor.
 */

package csp;

import java.io.FileNotFoundException;
import java.io.FileOutputStream;
import java.io.IOException;
import java.io.ObjectOutputStream;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Collections;
import java.util.HashSet;
import java.util.LinkedHashSet;
import java.util.LinkedList;
import java.util.Queue;
import java.util.Set;
import java.util.logging.Level;
import java.util.logging.Logger;
import javax.activation.UnsupportedDataTypeException;
import javax.swing.JOptionPane;
import javax.swing.JProgressBar;
import matlabcontrol.MatlabConnectionException;
import org.jdesktop.application.Application;
//import org.jfree.data.category.DefaultCategoryDataset;
//import org.jfree.data.xy.XYDataset;
//import org.jfree.data.xy.XYSeries;
//import org.jfree.data.xy.XYSeriesCollection;

/**
 *
 * @author Anurag
 */
public class CspProcess{
    //static boolean abToHoJaFlag;
    public boolean bMatlabDraw;
    private ArrayList<Chromosome> chromosomes_;
    private Queue<Chromosome> suspended_;
    private Chromosome bestSoFar;
    private double prevBest_;
    private double curBest_;
    private int stillSameBestCount;
    private ArrayList<Chromosome> solutions_;
    private ArrayList<ArrayList<Double>> chromeValues;
    private UserInput userInput_;
    private ExternalData externalData_;
    //private int population_;
    //private int generation_;
    private int poolSize_;
    private int tourSize_;
    private int knearest_;
    private String dataType_;
    private Double[] range_;
    private final int MAX_MOVES = 10;
    private final int MUM = 20;
    private final int MU = 20;
    private double MUTATION_RATE = 0.1;
    //private final int ARCHIVE_MAX;
    private final double REPLACE_PERCENT = 0.20; //8% PERCENT of chromosomes replaced by new population
    private final double IMMUNITY_PERCENT = 0.10; 
    private final double PARTIAL_SOL_PERCENT = 0.10;
    private MyRandom r_;
    private ArrayList<ArrayList<Double>> sameBestChromeVals_; //stores top ranked SAME_BEST_VAL_PERCENT % of chromosomes
    private int hasAllSame_; //counter to check if the SAME_BEST_VAL_PERCENT % of chromosomes is same for SAME_BEST_GENERATIONS generations
    private final double SAME_BEST_VAL_PERCENT = 0.1; //top ranked percentage of total chromosome population
    private final int SAME_BEST_GENERATIONS = 6;//measure to SAME_BEST_VAL_PERCENT % of top ranked chromosomes remain same for number of generations.
    private final int NO_PROGRESS_LIMIT = 6;//limit for no progress made in the NO_PROGRESS_LIMIT generations.
    private boolean bStagnant;
    private int stagnantVisit;
    public static double bringCloserRatio = 0.5;
    private boolean bOptimizationMode;
    /**
     *
     * @param userInput
     * @throws MyException
     */
    public CspProcess(UserInput userInput) throws MyException{
        //this();
        this.userInput_ = userInput;
        this.externalData_ = null;

        if(userInput_ == null){
            throw new MyException("No user input provided.", "Incorrect Data",JOptionPane.ERROR_MESSAGE);
        }

        initialize();
    } // Toavoid calling this constructor

    public CspProcess(ExternalData externalData)throws MyException{
        //this();
        this.externalData_ = externalData;
        this.userInput_ = this.externalData_.getUserInput();

        if(userInput_ == null || this.externalData_ == null){
            throw new MyException("No user input provided or empty external data.", "Incorrect Data",JOptionPane.ERROR_MESSAGE);
        }

        initialize();
    }

    private CspProcess(){
        ;
    }

    /**
     * private Constructor used only for default initialization
     */
    private void initialize() throws MyException{
        //abToHoJaFlag = false;
        bMatlabDraw = false;
        chromosomes_ = new ArrayList<Chromosome>();
        suspended_ = new LinkedList<Chromosome>();
        solutions_ = new ArrayList<Chromosome>();
        this.tourSize_ = 2; //default value assumed
        this.knearest_ = (int)(0.05*userInput_.population); //default value assumed
        this.r_ = new MyRandom();
        
        this.poolSize_ = userInput_.population/2; //default values assumed
        //ARCHIVE_MAX = userInput_.population/2;
        this.dataType_ = this.userInput_.dataType;

        this.range_ = new Double[userInput_.totalDecisionVars];
        for (int i = 0; i < userInput_.totalDecisionVars; i++) {
            this.range_[i] = 0.5; //double assumed.
        }

        if (this.userInput_.population < 5 || this.userInput_.generation < 1){
            throw new MyException("poulation size should be > 5 and generation should be > 1", "Input Data Error!",JOptionPane.ERROR_MESSAGE);
        }
        hasAllSame_ = 0;
        sameBestChromeVals_ = null;
        bStagnant = false;
        prevBest_ = Double.POSITIVE_INFINITY;
        curBest_ = Double.POSITIVE_INFINITY;
        stillSameBestCount = 0;
        stagnantVisit = 0;
        bOptimizationMode = false;
    }
    
    public ArrayList<Chromosome> getSolution(){
        return this.solutions_;
    }
    
    public ArrayList<Chromosome> getChromosomes(){
        return this.chromosomes_;
    }
    
    /**
     * It is the measure of novely. The larger the ro value the more the novelty
     * in the search space.
     * @param chrome
     * @return
     * @throws MyException
     * @throws UnsupportedDataTypeException 
     */
    double getRoValue(Chromosome chrome) throws MyException, UnsupportedDataTypeException{
        double ro;
        if(this.dataType_.contains("Integer")){
            ro = getIntegerRoValue(chrome);
        }
        else if(this.dataType_.contains("Double")){
            ro = getDoubleRoValue(chrome);
        }else{
            throw new UnsupportedDataTypeException("Only supports Integer and Double data type");
        }
        return ro;
    }
    
    /**
     * method determines ro value for nominal data types. the higher the better.
     * @param chrome
     * @return
     * @throws MyException 
     */
    double getIntegerRoValue(Chromosome chrome) throws MyException{
        double ro;
        ArrayList<Integer> validChromosomesIdx = new ArrayList<Integer>();
        Double []dist;
        int tempKnearest;
        
        if (chromosomes_.isEmpty()){
            throw new MyException("No chromosme population", "Variable Initialization Error",JOptionPane.ERROR_MESSAGE);
        }
 
        for (int i = 0; i < chromosomes_.size(); i++) {
            if (chromosomes_.get(i).getRank() != this.userInput_.totalConstraints)
                validChromosomesIdx.add(i);            
        }

        dist = new Double[validChromosomesIdx.size()];
        for (int i = 0; i < validChromosomesIdx.size(); i++) {
            dist[i] = MyMath.norm(chrome.getValsCopy(), chromosomes_.get(validChromosomesIdx.get(i)).getValsCopy(), MyMath.DIST_DUPLICATE_MISMATCH);
//            NOTE: I am using "SQUARE of distance" instead of just distance
//            because I will be using variance for ro_min.
            dist[i] = Math.pow(dist[i], 2);

        }
        Arrays.sort(dist);        
        // x1 itself is included in this set which should have the value 0.
        if(dist.length<=knearest_){ //////@Danger code............................
            tempKnearest = dist.length-1;
        }else{
            tempKnearest = knearest_;
        }
        ro = (1.0/tempKnearest) * MyMath.sum(dist, 0, tempKnearest);//Note: should not be knearest-1 as x1 itself is also included

        ro = MyMath.roundN(ro, 0); //to reduce so much variations...
        return ro;                     
    }
    
    /**
     * ro value determines the rank of novelty. The higher value the better.
     * @param chrome
     * @return
     * @throws MyException 
     */
    double getDoubleRoValue(Chromosome chrome) throws MyException{
        double ro;
        int maxViolation = this.userInput_.totalConstraints;
        ArrayList<Integer> validChromosomesIdx = new ArrayList<Integer>();
        Double []dist;
        int tempKnearest;
        
//        if(chrome.getRank() == maxViolation-1){
//            return -1.0;
//        }
        
        if (chromosomes_.isEmpty()){
            throw new MyException("No chromosme population", "Variable Initialization Error",JOptionPane.ERROR_MESSAGE);
        }
 
        for (int i = 0; i < chromosomes_.size(); i++) {
            if (chromosomes_.get(i).getRank() != maxViolation)
                validChromosomesIdx.add(i);            
        }

        dist = new Double[validChromosomesIdx.size()];
        for (int i = 0; i < validChromosomesIdx.size(); i++) {
            dist[i] = MyMath.norm(chrome.getValsCopy(), chromosomes_.get(validChromosomesIdx.get(i)).getValsCopy(), MyMath.DIST_EUCLEADIAN);
//            NOTE: I am using "SQUARE of distance" instead of just distance
//            because I will be using variance for ro_min.
            dist[i] = Math.pow(dist[i], 2);

        }
        Arrays.sort(dist);        
        // x1 itself is included in this set which should have the value 0.
        if(dist.length<=knearest_){ //////@Danger code............................
            tempKnearest = dist.length-1;
        }else{
            tempKnearest = knearest_;
        }
        ro = Math.pow(1.0/tempKnearest, 2) * MyMath.sum(dist, 0, tempKnearest);//Note: should not be knearest-1 as x1 itself is also included

        ro = MyMath.roundN(ro, 0);
        return ro;
    }


    /**
     * Starts the whole process
     */
    public void start(JProgressBar pb, boolean saveChromes, ByRef nextPrefSuggestion) throws MyException{
        ArrayList<Chromosome> parents;
        ArrayList<Chromosome> offspring;
        ArrayList<Chromosome> temp;
        ArrayList<Chromosome> CSPsols = new ArrayList<Chromosome>();
        Chromosome tempChrom;
        double startTime = 0.0;
        double endTime = 0.0;
        int totalSaved;
        int g = 0; //generation
        Draw d = null;        
  
        try{
            if(bMatlabDraw){
                d = new Draw();                
                d.draw(matlabPlotBuildConstraints());  
            }
            
            initializeChromosomes(this.chromosomes_, userInput_.population, g);
            bestSoFar = this.chromosomes_.get(0);
                                    
            startTime = System.nanoTime();
            startTime = startTime/Math.pow(10, 9);

            for (g = 1; g <= userInput_.generation; g++) {
                //if(g < userInput_.generation-1){ 
                    CSPsols = new ArrayList<Chromosome>(); 
                    if(bestSoFar.isSolution()){
                        for (int i = 0; i < 1; i++) {
                            for (Chromosome ch : chromosomes_) {
                                if(ch.isSolution()){ 
                                    tempChrom = (Chromosome)ch.clone();
                                    mutationSwap(tempChrom);
                                    CSPsols.add(tempChrom);
                                }
                            }
                            for (Chromosome ch : chromosomes_) {
                                if(ch.isSolution()){ 
                                    tempChrom = (Chromosome)ch.clone();
                                    mutationGroupSwap(tempChrom);
                                    CSPsols.add(tempChrom);
                                }
                            }
                        }

                       
                    }
                
                    parents = noveltyTournamentSelection(); //select best parents only.
                    offspring = interRaceCrossover(parents); //crossover selected parents only   
                    mutation(offspring);//mutating crossovered offspring only                                    
                    parents.clear();//no longer needed
                                     

                    //System.out.println("size "+offspring.size());
                    //chromosomes_ = new ArrayList<Chromosome>(chromosomes_.subList(0, userInput_.population - offspring.size()));
                    
//                    if(bOptimizationMode){
//                        chromosomes_.clear(); // Just added out of the blue...                        
//                    }
                                       
                    chromosomes_.addAll(offspring);//include all offspring into the chromosome set.
                                    
                    chromosomes_.addAll(CSPsols);
                    
                    //Set<Chromosome> s = new LinkedHashSet<Chromosome>(chromosomes_);
                    //chromosomes_ = new ArrayList<Chromosome>(s); 
                    setUniqueChromosomes();                                    
                    
                    temp = new ArrayList<Chromosome>();
                    initializeChromosomes(temp, userInput_.population-chromosomes_.size(), g);
                    chromosomes_.addAll(temp);
                                    
                    
                    sortAndReplace(g);//sort according to least violation first then on ro value (novelty)    


                    System.out.println("Gen: "+g); //+"best rank: " + bestSoFar.getRank() 
//                            + ", fitness: "+ bestSoFar.getFitnessVal(0)
//                            + ", rank list: " + bestSoFar.getSatisfaction() + ", vals: " + bestSoFar.getValsCopy());
                    bestSoFar.tempSortBy = userInput_.solutionBy;
                    System.out.println(bestSoFar);
                    
                    System.out.println("top ones...");
                    for (int i = 0; i < chromosomes_.size(); i++) {
                        System.out.print(chromosomes_.get(i).getValsCopy().size()+", ");
                    }
                    
                    
                        
                 
                    
                    System.out.println();                                                                   
               // }
                
                if(bMatlabDraw){
                    d.draw(matlabPlotBuildGeneration(g));
                }
                
                if(pb != null)
                    pb.setValue(pb.getMinimum()+(pb.getMaximum()-pb.getMinimum())*g/(userInput_.generation));
            }            
        }catch(SolutionFoundException SFE){
            System.out.println("Solution found at generation " + (g));
            try {
                if(bMatlabDraw){
                    d.draw(matlabPlotBuildGeneration(g));
                }
            } catch (Exception e) {
                e.printStackTrace();
            }
            g = userInput_.generation;
            pb.setValue(pb.getMinimum()+(pb.getMaximum()-pb.getMinimum())*g/(userInput_.generation));            
        }catch(MyException me){
            me.showMessageBox();
        }catch(UnsupportedDataTypeException udte){
            udte.printStackTrace();
        }catch (MatlabConnectionException mce) {
            mce.printStackTrace();           
        }
        catch(Exception e){
            e.printStackTrace();
            throw new MyException("Exception raised in Start Process", "Check Start Process()",JOptionPane.ERROR_MESSAGE);           
        }finally{
            endTime = System.nanoTime();
            endTime = endTime/Math.pow(10, 9);
            System.out.println("Process time(Sec): " + MyMath.roundN(endTime - startTime,2));
            System.out.println("Total Evaluations: "+ Chromosome.totalEvals);
            
            System.err.flush();
            System.out.flush();
            //Thread.currentThread().sleep(100);//sleep for 1000 ms

            setSolution();
            if(this.solutions_.isEmpty()){                            
                System.out.println("No Solution Found :( ****************");
                System.out.println("total chromosomes: "+chromosomes_.size());
                System.out.println("best chromosomes\n" + bestSoFar);
                System.out.println("val size: "+bestSoFar.getValsCopy().size());
            }else{
                System.out.println("Solution Found");
                //System.out.println(this.solutions_.get(0));//????????????????????????????
                System.out.println("best chromosomes\n" + bestSoFar);
            }  
            
            if(externalData_ != null){ //external data is used.  
                nextPrefSuggestion.setVal(String.valueOf(externalData_.getNextPrefLimit()));
                String fileName = "partial_solutions_pref_"+externalData_.getCurPref()+".ichea";
                try {
                    FileOutputStream fos;
                    fos = new FileOutputStream(fileName);
                    ObjectOutputStream oos = new ObjectOutputStream(fos);

                    Set<Chromosome> s = new LinkedHashSet<Chromosome>(chromosomes_);
                    chromosomes_ = new ArrayList<Chromosome>(s); 
                    totalSaved = Math.min(chromosomes_.size(),(int)(PARTIAL_SOL_PERCENT*userInput_.population));
                    
                    chromosomes_ = new ArrayList<Chromosome>(chromosomes_.subList(0, totalSaved));
                    chromosomes_.add(0, bestSoFar);
                    for (Chromosome c : chromosomes_) {
                        c.refreshFitness();
                    }
                    
                    oos.writeObject(chromosomes_);//chromosomes_.subList(0, (int)(PARTIAL_SOL_PERCENT*userInput_.population)));
                    oos.flush();
                    oos.close();
                    System.out.println("["+ totalSaved + "] chromosomes of data successfully Saved to File ["+fileName+"].");
                } catch (FileNotFoundException fnfe) {
                    System.err.println("Serialize Error! File cannot be created.");
                } catch (IOException ioe){
                    ioe.printStackTrace();
                    System.err.println("Serialize Error! Cannot write to the file ["+fileName+"].");
                }                
            }
        }    
    }

    private ArrayList<String> matlabPlotBuildGeneration(int generation) throws Exception{
        ArrayList<String> MatlabCommands = new ArrayList<String>();
        ArrayList<Double> drawXdata;
        ArrayList<Double> drawYdata;
        
        if (userInput_.totalDecisionVars != 2){
            throw new Exception("Draw Error! Only 2D draw is allowed.");
        } 
        
                
        if(generation <= 1){
            MatlabCommands.add("hdata = plot(0,0,\'+b\');");
        }

        MatlabCommands.add("title(\'Gen: " + generation + "\');");                

        drawXdata = new ArrayList<Double>();
        drawYdata = new ArrayList<Double>();
        for (Chromosome c : chromosomes_) {
            drawXdata.add(c.getVals(0));//x axis;
            drawYdata.add(c.getVals(1));//y axis
        }
        MatlabCommands.add("set(hdata,\'XData\'," + drawXdata.toString() + ");"); 
        MatlabCommands.add("set(hdata,\'YData\'," + drawYdata.toString() + ");");
        MatlabCommands.add("refreshdata(hdata)");
        MatlabCommands.add("drawnow;");

        return MatlabCommands;
    }
    
    private ArrayList<String> matlabPlotBuildConstraints(){
        ArrayList<String> commands = new ArrayList<String>();
        
                commands.add("hold on;");
        commands.add("x = [-100:0.1:100];");
        commands.add("br = 10.0;");
        commands.add("sr = 9.9;");
        commands.add("y1p = sqrt(br^2 - x.^2);");
        commands.add("y1m = -sqrt(br^2 - x.^2);");
        commands.add("y2p = sqrt(sr^2 - x.^2);");
        commands.add("y2m = -sqrt(sr^2 - x.^2);");
        
        commands.add("y3p = sqrt(br^2 - (x+2*br - 0.1).^2);");
        commands.add("y3m = -sqrt(br^2 - (x+2*br - 0.1).^2);");
        commands.add("y4p = sqrt(sr^2 - (x+2*br - 0.1).^2);");
        commands.add("y4m = -sqrt(sr^2 - (x+2*br - 0.1).^2);");


        commands.add("fig1 = gcf;"); //get current figure or create figure fig1
        commands.add("axes1 = axes('Parent',fig1);"); //Create axes
        
        commands.add("ylim(axes1,[-100 100]);");
        commands.add("box(axes1,'on');");
        commands.add("hold(axes1,'all');");
        commands.add("plot(x,y1p);");
        commands.add("plot(x,y1m,'Parent',axes1);");
        commands.add("plot(x,y2p,'Parent',axes1);");
        commands.add("plot(x,y2m,'Parent',axes1);");
        commands.add("plot(x,y3p,'Parent',axes1);");
        commands.add("plot(x,y3m,'Parent',axes1);");
        commands.add("plot(x,y4p,'Parent',axes1);");
        commands.add("plot(x,y4m,'Parent',axes1);");
                
        
//        commands.add("hold on;");
//        commands.add("X1 = [-100:1:100];");
//        commands.add("YMatrix1 = -9*X1+6.0;");
//        commands.add("YMatrix2 = 9*X1 - 1.0;");
////        commands.add("XMatrix3 = 1;");
////        commands.add("XMatrix4 = 0;");
//        commands.add("YMatrix3 = -9*X1+7.0;");
//        commands.add("YMatrix4 = 9*X1 - 2.0;");
//
//        commands.add("fig1 = gcf;"); //get current figure or create figure fig1
//        commands.add("axes1 = axes('Parent',fig1);"); //Create axes
//        
//        commands.add("ylim(axes1,[-100 100]);");
//        commands.add("box(axes1,'on');");
//        commands.add("hold(axes1,'all');");
//        commands.add("plot(X1,YMatrix1);");
//        commands.add("plot(X1,YMatrix2,'Parent',axes1);");
////        commands.add("plot(XMatrix3,X1,'Parent',axes1);");
////        commands.add("plot(XMatrix4,X1,'Parent',axes1);");
//        commands.add("plot(X1,YMatrix3,'Parent',axes1);");
//        commands.add("plot(X1,YMatrix4,'Parent',axes1);");
        
        return commands;
    }
    
    /**
     * Remove stagnant best values from the population of chromosomes.
     * preprocess - chromosome population should be sorted and contains unique
     * chromosomes.
     * @param PERCENT - what PERCENT of chromosomes to be checked.
     * @param sameBestVals - Arraylist of same best val
     * @param sameGens - same best val for how many generations
     * @return
     */
//    private boolean isStagnant(){    
//        boolean allsame;
//        boolean bstagnant;
//        bstagnant = false;
//        allsame = false;
//        ArrayList<ArrayList<Double>> diverse;
//
//        if(sameBestChromeVals_ != null)
//            diverse = (ArrayList<ArrayList<Double>>)sameBestChromeVals_.clone();
//        else{
//            diverse = new ArrayList<ArrayList<Double>>();
//            sameBestChromeVals_ = new ArrayList<ArrayList<Double>>();
//        }
//
//        for (int ofsp = 0; ofsp < (int)(SAME_BEST_VAL_PERCENT*userInput_.population); ofsp++) {
//            diverse.add(chromosomes_.get(ofsp).getValsCopy());
//        }
//        
//        HashSet<ArrayList<Double>> hashSet = new HashSet<ArrayList<Double>>(diverse);
//        diverse = new ArrayList<ArrayList<Double>>(hashSet);
//
//        if(diverse.size() == sameBestChromeVals_.size()){
//            allsame = true;
//        }else{            
//            sameBestChromeVals_ = new ArrayList<ArrayList<Double>>();
//            for (int ofsp = 0; ofsp < (int)(SAME_BEST_VAL_PERCENT*userInput_.population); ofsp++) {
//                sameBestChromeVals_.add(chromosomes_.get(ofsp).getValsCopy());
//            }            
//        }
//
//        if(allsame){
//            hasAllSame_++;
//        }else{
//            hasAllSame_ = 0;
//        }
//
//        if(hasAllSame_ >= SAME_BEST_GENERATIONS){
//            hasAllSame_ = 0;
//            sameBestChromeVals_ = null;
//            bstagnant = true;
//        }
//
//        return bstagnant;
//    }

    private void initializeChromosomes(ArrayList<Chromosome> chromosome, final int SIZE, final int gen) throws Exception {
        boolean bInitialStage;
        if(SIZE<=0){
            chromosome = null;
            return;
        }
        
        if (externalData_ != null){
            if(gen<10){
                bInitialStage = true;
            }else{
                bInitialStage = false;
            }
                
            chromosome.addAll(externalData_.initializeExternalChrmosomes(SIZE));
        }else{
            initializeChromosomesRandomly(chromosome,SIZE);
        }
    }

    /**
     * Initializes Chromosomes with random values
     */
    private void initializeChromosomesRandomly(ArrayList<Chromosome> chromosome, final int SIZE) throws Exception{
        Object rand = null;
        Chromosome tempChromosome;
               
        for (int i = 0; i < SIZE; i++) {
            tempChromosome = new Chromosome(this.userInput_);
            for (int j = 0; j < userInput_.totalDecisionVars; j++) {
                if (userInput_.dataType.contains("Integer")){
                    rand = r_.randVal(userInput_.minVals.get(j).intValue(), userInput_.maxVals.get(j).intValue());
                }else if (userInput_.dataType.contains("Double")){
                    rand = r_.randVal((Double)userInput_.minVals.get(j), (Double)userInput_.maxVals.get(j));
                }
                else{
                    System.err.println("Incorrect use of data types");
                    System.exit(1);
                }
                tempChromosome.appendVal((Double)rand);
            }
            chromosome.add(tempChromosome);
        }        
    }

//    private void setFitness(ArrayList<Chromosome> chromosome, final int SIZE){
//        for (int ofsp = 0; ofsp < SIZE; ofsp++) {
//            //ObjectiveFunction.definition(chromosome.get(ofsp));
//            chromosome.get(ofsp).setObjectiveFunctionVars();
//        }
//    }

    /**
     * noveltyTournamentSelection() - Tournament selection based on novelty
     * of the chromosome in the population.
     * @return Returns ArrayList<Chromosome> of parent selected population 
     */
    private ArrayList<Chromosome> noveltyTournamentSelection() throws MyException, UnsupportedDataTypeException{
        ArrayList<Chromosome> candidates = new ArrayList<Chromosome>();
        ArrayList<Chromosome> parents = new ArrayList<Chromosome>(); // shoud have this.pool sizse
        ArrayList<Integer> temp;
        double csize0, csize1;
        double ro0, ro1;
        int candidate0dominates;
        
        if(this.tourSize_ != 2){
            throw new MyException("Tour Should be 2", "Inappropriate Tour Size",JOptionPane.ERROR_MESSAGE);
        }
                 
        for (int p = 0; p < this.poolSize_; p++) {
            //select tourSize_ chromosomes k.e 2 chromosomes randomly from the population
            temp = MyRandom.randperm(0, chromosomes_.size()-1);
            candidates.clear();
            for (int t = 0; t < this.tourSize_; t++) {                
                candidates.add(chromosomes_.get(temp.get(t)));
            }
            temp = null;
            
//            //violation prefered technique
//            //<<
//            //Pick the candidate with lower violations
//            csize0 = candidates.get(0).getRank();
//            csize1 = candidates.get(1).getRank();
//            
//            if (csize0 < csize1){ // the lower the better
//                parents.add(candidates.get(0));                
//            }
//            else if (csize1 < csize0){
//                parents.add(candidates.get(1));                
//            }
//            else{
//                int candidate0dominates = 0;
//                    
//                for (int ofsp = 0; ofsp < userInput_.totalConstraints; ofsp++) {
//                    if(candidates.get(0).correspondingBoundaryDist().get(ofsp) < candidates.get(1).correspondingBoundaryDist().get(ofsp))
//                        candidate0dominates++;
//                }
//
//                if(candidate0dominates == userInput_.totalConstraints){
//                    parents.add(candidates.get(0));  
//                }else if(candidate0dominates == 0){
//                    parents.add(candidates.get(1));  
//                }else{
//                
//                    ro0 = getRoValue(candidates.get(0));
//                    ro1 = getRoValue(candidates.get(1));
//                    if (ro0 > ro1) // the larger the better
//                        parents.add(candidates.get(0));
//                    else if (ro1 > ro0)
//                        parents.add(candidates.get(1));
//                    else{
//                        if(candidates.get(0).isStagnant(this.NO_PROGRESS_LIMIT)){
//                            parents.add(candidates.get(1));
//                        }else if(candidates.get(1).isStagnant(this.NO_PROGRESS_LIMIT)){
//                            parents.add(candidates.get(0));
//                        }else{
//                            diverse = MyRandom.randperm(0, 1);
//                            parents.add(candidates.get(diverse.get(0)));
//                        }               
//                    }   
//                }
//            } 
            //>>
            
            
            
           //if(bStagnant){
//                candidate0dominates = 0;
//                    
//                for (int ofsp = 0; ofsp < userInput_.totalConstraints; ofsp++) {
//                    if(candidates.get(0).correspondingBoundaryDist().get(ofsp) < candidates.get(1).correspondingBoundaryDist().get(ofsp))
//                        candidate0dominates++;
//                }
//
//                if(candidate0dominates == userInput_.totalConstraints){
//                    parents.add(candidates.get(0));  
//                }else if(candidate0dominates == 0){
//                    parents.add(candidates.get(1));  
//                }else{
//                
//                    csize0 = candidates.get(0).getRank();
//                    csize1 = candidates.get(1).getRank();
//
//                    if (csize0 < csize1){ // the lower the better
//                        parents.add(candidates.get(0));                
//                    }
//                    else if (csize1 < csize0){
//                        parents.add(candidates.get(1));                
//                    }
//                    else{   
//                    
//                        ro0 = getRoValue(candidates.get(0));
//                        ro1 = getRoValue(candidates.get(1));
//                        if (ro0 > ro1 || candidates.get(0).getValsCopy().size() == 1) // the larger the better
//                            parents.add(candidates.get(0));
//                        else if (ro1 > ro0 || candidates.get(1).getValsCopy().size() == 1)
//                            parents.add(candidates.get(1));
//                        else{
//                            diverse = MyRandom.randperm(0, 1);
//                            parents.add(candidates.get(diverse.get(0)));
//                        }
//                    }  
//                }
//            }
//           else{
//                //novelty prefered technique
//                //<<
//                //Pick the candidate with lower violations  
            
//            if(candidates.get(0).getImmunity() > candidates.get(1).getImmunity()){
//                parents.add(candidates.get(0));
//            }else if(candidates.get(1).getImmunity() > candidates.get(0).getImmunity()){
//                parents.add(candidates.get(1));
//            }else{
//            if(candidates.get(0).getFitnessVal(0) < candidates.get(1).getFitnessVal(0)){
//                parents.add(candidates.get(0));
//            }else if(candidates.get(1).getFitnessVal(0) < candidates.get(0).getFitnessVal(0)){
//                parents.add(candidates.get(1));
//            }else{
            try{
                ro0 = getRoValue(candidates.get(0)); //do not need to use getRo function, check sortnreplace function if it has already been set in tempRo property.
                ro1 = getRoValue(candidates.get(1));
            
                if (ro0 > ro1 || candidates.get(0).getValsCopy().size() == 1) // the larger the better
                    parents.add(candidates.get(0));
                else if (ro1 > ro0 || candidates.get(1).getValsCopy().size() == 1)
                    parents.add(candidates.get(1));
                else{
                    csize0 = candidates.get(0).getRank();
                    csize1 = candidates.get(1).getRank();

                    if (csize0 < csize1){ // the lower the better
                        parents.add(candidates.get(0));                
                    }
                    else if (csize1 < csize0){
                        parents.add(candidates.get(1));                
                    }
                    else{                    
                        candidate0dominates = 0;

                        if(candidates.get(0).isStagnant(this.NO_PROGRESS_LIMIT)){
                            parents.add(candidates.get(1));
                        }else if(candidates.get(1).isStagnant(this.NO_PROGRESS_LIMIT)){
                            parents.add(candidates.get(0));
                        }else{
                            temp = MyRandom.randperm(0, 1);
                            parents.add(candidates.get(temp.get(0)));
                        }
                    }                                    
                }
                }catch(Exception e){
                e.printStackTrace();
            }
//            //>>
        }                
        
        return parents;
    }
    
    /**
     * IMPROPER METHOD... NEEDS CORRECTION.... Checks if the solution for CSP has been achieved
     * @return Returns ArrayList<Chromosome> of solution chromosomes.
     */
    private void setSolution(){
        //ArrayList<ArrayList<Double>> duplicates = new ArrayList<ArrayList<Double>>();
        chromeValues = new ArrayList<ArrayList<Double>>();
        int beforeSize, afterSize;
                
        for (Chromosome chromosome : this.chromosomes_) {
            if(chromosome.isSolution()){ // no violations
                beforeSize = chromeValues.size();  
                //Collections.sort(chromosome.getValsCopy());
                chromeValues.add(chromosome.getValsCopy());
                //this.solutions_.add(chromosome); 
                
                
                HashSet<ArrayList<Double>> hashSet = new HashSet<ArrayList<Double>>(chromeValues);
                chromeValues = new ArrayList<ArrayList<Double>>(hashSet);            
                afterSize = chromeValues.size();
            
                if(afterSize>beforeSize){
                    this.solutions_.add(chromosome);
                }            
            }
        }            
    }
    
    public String printChromeValues(){
        String str;
        
        str = Integer.toString(chromeValues.size()) + "\n";
        str += Integer.toString(this.userInput_.totalConstraints) + "\n";
        for (int i = 0; i < chromeValues.size(); i++) {
            for (int j = 0; j < chromeValues.get(i).size(); j++) {
                str += chromeValues.get(i).get(j).toString() + " ";                
            }
            str += "\n";            
        }
        return str;
    }
    
    private Chromosome notVals(Chromosome in){
        Chromosome out;
        
        Double[] temp = new Double[userInput_.totalConstraints];
        for (int i = 0; i < temp.length; i++) {
            temp[i] = i*1.0;            
        }
        
        for (Double d : in.getValsCopy()) {
            temp[d.intValue()] = -1.0;
        }
        
        ArrayList<Double> notVal = new ArrayList<Double>();
        
        
        for (int i = 0; i < temp.length; i++) {
            if(temp[i]!=-1.0){
                notVal.add(temp[i]);
            }       
        }
        
        out = (Chromosome)in.clone();
        out.setVals(notVal);
        return out;
    }

     /**
     * inter race crossover - offers crossover between 2 different constraint regions only
     * the offspring will have better or same constraint violation than their parents.
     * This process requires 2 parents that produce 2 offspring
     * @param parents list of parents
     * @return returns offspring
     * @throws MyException
     * @throws UnsupportedDataTypeException
     */
    private ArrayList<Chromosome> interRaceCrossover(final ArrayList<Chromosome> parents) throws MyException, UnsupportedDataTypeException{
        ArrayList<Chromosome> candidates = new ArrayList<Chromosome>(this.tourSize_);
        ArrayList<Chromosome> offspring = new ArrayList<Chromosome>();
        ArrayList<Integer> tempIntAL; 

        //ArrayList<Double> directions;
        //ArrayList<Double> approachDist = new ArrayList<Double>(1);
        
        //double maxDist;
        //double ratio;
        int count;
        
        if(this.tourSize_ != 2){
            throw new MyException("Tour Should be 2", "Inappropriate Tour Size",JOptionPane.ERROR_MESSAGE);
        }
        
        if(parents.isEmpty()){
            System.out.println("Sigh! no parents!");
        }
        
        for (int i = 0; i < userInput_.population/2; i++) {
            if(Math.random() < 0.9){
                //Randomly pick two parents.
                tempIntAL = MyRandom.randperm(0, parents.size()-1);
                candidates.clear();
                for (int t = 0; t < this.tourSize_; t++) {                
                    candidates.add(parents.get(tempIntAL.get(t)));
                }
                
                try{
                    //Note here we can make integer and double combined problem
                    //set as well.
                    if(dataType_.contains("Integer")){
                        count = this.tourSize_;
                        //while both parents belong to same Constraint region
                        //Drawback - this will case very few crossover + very few
                        //final solutions. That might affect the optimization
                        //problem where we need many candidate solutions.
    //                    while(candidates.get(0).violations.containsAll(candidates.get(1).violations) &&
                        
//                        if(bStagnant && bestSoFar.getValsCopy().size() != userInput_.totalConstraints){
//                            candidates.clear();
//                            candidates.add(bestSoFar);
//                            candidates.add(notVals(bestSoFar));
//                        }else{
                            while(candidates.get(0).hasSameRankComponent(candidates.get(1))){// &&
                                    //candidates.get(0).getRank() == candidates.get(1).getRank()){
                                candidates.remove(1);
                                candidates.add(parents.get(tempIntAL.get(count)));
                                count++;
                                if(count >= parents.size()){
                                    //candidates.add(parents.get(tempIntAL.get(immuneCount-1)));
                                    break;
                                    //throw new MyException("No unique parents exist", "Parents in crossover",JOptionPane.WARNING_MESSAGE);
                                }
                            }
//                        }
                        
                        offspring.addAll(interRaceCrossoverInteger(candidates));//only 1 move
                        
                        
                    }else if(dataType_.contains("Double")){
                        //further filter for boundary intersections... 
                        count = this.tourSize_;

                        while(!candidates.get(0).isMarriageCompatible(candidates.get(1))){
                            candidates.remove(1);
                            candidates.add(parents.get(tempIntAL.get(count)));
                            count++;
                            if(count >= parents.size()){                            
                                break;                            
                            }
                        }
                        offspring.addAll(interRaceCrossoverDouble(this.MAX_MOVES, candidates));
                    }else{
                        throw new UnsupportedDataTypeException("Only supports Integer and Double");
                    }         

                }catch (UnsupportedDataTypeException udte) {
                    throw new UnsupportedDataTypeException("Check your data type");
                }
//                catch (MyException me){
//                    me.printMessage();
//                }
            }
        }

        return offspring;
    }

    /**
     * interRaceCrossoverInteger - is used only with nominal data types. for integer data
     * use interRaceCrossoverDouble. it virtually moves 2 parents.
     * @param move
     * @param candidates - parents from which offspring are sought.
     * @return returns offspring from given candidate parents
     */
    private ArrayList<Chromosome> interRaceCrossoverInteger(final ArrayList<Chromosome> candidates){
        ArrayList<Chromosome> offspring = new ArrayList<Chromosome>();
        ArrayList<Integer> idx = new ArrayList<Integer>();
        Chromosome tempChrome;
        int move;
        boolean isSol;
        
        if (candidates.size() != 2){
            throw new UnsupportedOperationException("Require only 2 parents");
        }
        
        isSol = false;
        for (Chromosome can : candidates) {
            if(can.isSolution()){
                isSol = true;
                break;
            }
        }
        
        //Check common values in both candidate parents.
        int [] commonVals = new int[userInput_.totalConstraints]; //all initialized to 0
        int constVal = 1;
        
        
        for (int j = 0; j < candidates.size(); j++) {
            for (double v : candidates.get(j).getValsCopy()) {
                commonVals[(int)v] += constVal;
            }
            constVal = constVal*10;
        }
        //Those commonVals that have value 11 as element value, it means that is common in both parents.
        //otherwise it will have 1 or 10 respectively for both parents.
       
        int prevLength, newLength;
        //Technique 1 - Append chromosomes- multi-offpring (0-n) afrom 2 parents. - 
        //<< Build up structure for satisfaction list
//        if(Math.random() < 0.5){//5 && !isSol){ //!bStagnant){ //obviously Math.random is always [0 1)
//        if(!bOptimizationMode){
        if(!isSol){
            constVal = 1;
            for (int j = 0; j < candidates.size(); j++) {
                tempChrome = (Chromosome)candidates.get((j+1)%tourSize_).clone();
                prevLength = tempChrome.noGood.size();
                
                for (int i = 0; i < commonVals.length; i++) {
                    if(commonVals[i]==constVal){
                        tempChrome.appendVal(i);//NOTE ofsp want getSatisfaction value but in this case both are same
                    }                    
                }

                newLength = tempChrome.noGood.size();
                
                if(newLength > prevLength){ //nogood added
                    tempChrome.forceFindSolution();
                }
                offspring.add((Chromosome)tempChrome);
                constVal = constVal*10;
            }

        }
        
//        for no goods... 
//        first remove all duplicates....
//        cross-over..
        
        //>>

        //Technique 2(a) - 1 point crossover, where split point is the half of the size of chromosome
        //crossover first half of one chromosome with second half of another chrromosome
        //<< Rebuild the satisfaction structure - because the solution is stagnant.
////        if(offspring.isEmpty()){
        else{ 
            Chromosome p0;
            Chromosome p1;
            Chromosome init_p0;
            int part0, part1;
            final double PERCENT = 0.75;

            try{
                part0 = (int)Math.ceil(candidates.get(0).getValsCopy().size()*PERCENT);
                part1 = (int)Math.ceil(candidates.get(1).getValsCopy().size()*PERCENT);

                p0 = (Chromosome)candidates.get(0).clone();
                init_p0 = (Chromosome)p0.clone();
                p1 = (Chromosome)candidates.get(1).clone();

                if(part0 <=1 || part1 <=1){
                    p0.appendVal(candidates.get(1).getVals(0));
                    offspring.add(p0);
                    p1.appendVal(candidates.get(0).getVals(0));
                    offspring.add(p1);
                    return offspring;
                }               
                
                p0.restructure(1-PERCENT, true);
                p1.restructure(1-PERCENT, false);
                
                if(p0.getValsCopy().isEmpty() || p1.getValsCopy().isEmpty()){
                    System.out.println("stope reee...");
                }
                
                //add half one at a time
                for (int i = 0; i < p1.getValsCopy().size(); i++) {
                    prevLength = p0.noGood.size();
                    p0.appendVal(p1.getVals(i)); //here val and satisfaction values are same so getVal() method is fine here
                    newLength = p0.noGood.size();
                    if(newLength > prevLength){ //nogood added
                        p0.forceFindSolution();
                    }
                }
                
                //add half one at a time
                for (int i = 0; i < init_p0.getValsCopy().size(); i++) {
                    prevLength = p1.noGood.size();
                    p1.appendVal(init_p0.getVals(i)); //here val and satisfaction values are same so getVal() method is fine here
                    newLength = p1.noGood.size();
                    if(newLength > prevLength){ //nogood added
                        p1.forceFindSolution();
                    }
                }
                
                //rank check??????????????
//                if(p0.getRank() <= candidates.get(0).getRank())
                    offspring.add(p0);
//                if(p1.getRank() <= candidates.get(1).getRank())
                    offspring.add(p1);
                
////                //here val and satisfaction values are same so getVal() method is fine here
////                p0.setVals(new ArrayList<Double>(p0.getValsCopy().subList(0, part0)));
////
////                //add later half one at a time
////                for (int ofsp = part1; ofsp < candidates.get(1).getValsCopy().size(); ofsp++) {
////                    p0.appendVal(candidates.get(1).getVals(ofsp)); //here val and satisfaction values are same so getVal() method is fine here
////                }
////
////                
////                //again val and satisfaction values are same so getVal() method is fine here
////                p1.setVals(new ArrayList<Double>(p1.getValsCopy().subList(0, part1)));
////
////                //add later half
////                for (int ofsp = part0; ofsp < candidates.get(0).getValsCopy().size(); ofsp++) {
////                    p1.appendVal(candidates.get(0).getVals(ofsp));
////                }
////
////                //rank check??????????????
//////                if(p0.getRank() <= candidates.get(0).getRank())
////                    offspring.add(p0);
//////                if(p1.getRank() <= candidates.get(1).getRank())
////                    offspring.add(p1);
            }catch(IndexOutOfBoundsException e){
                System.err.println("No offspring\n" + e.getLocalizedMessage());
            }
        }
        
        return offspring;
    }
   
    
    /**
     * interRaceCrossoverDouble - can be used for interger or double data types.
     * double crossover reqires 2 parents and generate 2 offspring
     * process: the original genes of parents are moved closer to each other until
     * the better or same ofsp.e. (less or equal violations) is reached. the number
     * of moves is determined by  move parameter
     * @param move - number of maximum moves until the better/same solution is reached
     * @param candidates Two parents
     * @return Two offspring
     * @throws UnsupportedDataTypeException
     */
    private ArrayList<Chromosome> interRaceCrossoverDouble(final int move, ArrayList<Chromosome> candidates) throws UnsupportedDataTypeException{
        ArrayList<Double> delta;
        ArrayList<Double> newDelta;
        ArrayList<Chromosome> offspring = new ArrayList<Chromosome>(tourSize_);
        Chromosome childChrome;

        if (candidates.size() != 2){
            throw new UnsupportedOperationException("Require only 2 parents");
        }
      
        for (int j = 0; j < this.tourSize_; j++) {
            //directions = MyAlgorithms.getDirection(candidates.get(j).getValsCopy(), candidates.get((j+1)%tourSize_).getValsCopy());
            //maxDist = MyMath.norm(candidates.get(j).getValsCopy(), candidates.get((j+1)%tourSize_).getValsCopy(), MyMath.DIST_EUCLEADIAN);
            delta = MyMath.vectorSubtraction(candidates.get((j+1)%tourSize_).getValsCopy(), candidates.get(j).getValsCopy());

            for (int k = 1; k <= move; k++) {
                //find which direction to move?
                childChrome = new Chromosome(this.userInput_);
                //approachDist = Math.pow(ratio,k)*maxDist;                
                newDelta = MyMath.constMultiplicationToVector(Math.pow(bringCloserRatio,k), delta);     
                childChrome.setVals(MyMath.vectorAddition(candidates.get(j).getValsCopy(), newDelta));

                //vp = new VirusProliferate(movingChrome.vals.toArray(), this.range_);

                //**************************************************************************************************************//
                //NOTE: ofsp changed <= sign to < sign
                //It is now giving me less solutions
                //It is good or bad......... I don't know.... It only promotes local search.
                if(childChrome.getRank() <= candidates.get(j).getRank()){                    
                    if(childChrome.getRank() == 0 || candidates.get(j).isMyChild(childChrome)){
                        offspring.add(childChrome);
                        break;
                    }
                }
            }
        }
        return offspring;
    }



    /**
     * Mutate the given set of offspring.
     * @param offspring mutation applied only to offspring
     */
    private void mutation(ArrayList<Chromosome> offspring) throws UnsupportedDataTypeException{
        if(offspring.isEmpty()){
            return;
        }
        if(!userInput_.doMutation){
            return;
        }

         //update the offspring
        if(this.dataType_.contains("Integer")){
            mutationInteger(offspring);
        }
        else if(this.dataType_.contains("Double")){
            mutationDouble(offspring);
        }else{
            throw new UnsupportedDataTypeException("Only supports Integer and Double data type");
        }
    }

     /**
     * mutationDouble only mutate Doubles. It uses Polynomial Mutation as described in NSGA - II <br>
     * <B>Note</B> that offspring ArrayList is updated here.
     * @param offspring offspring generated after crossover.
     */
    private void mutationDouble(ArrayList<Chromosome> offspring){
        int size = offspring.size();
        ArrayList<Integer> randInts;
        Chromosome temp;
        double val;
        double rand;
        double add;
        
        for (int i = 0; i < size; i++) {
            
            try{
                if(Math.random()<1.0/userInput_.totalDecisionVars){
                    randInts = MyRandom.randperm(0, size-1);
                    temp = offspring.get(randInts.get(0));

                    for (int j = 0; j < userInput_.totalDecisionVars; j++) {
                        val = temp.getVals(j);
                        rand = Math.random();
                        if(rand<0.5)
                            add = Math.pow(2.0*rand,1.0/(MUM+1)) -1;
                        else
                            add = 1- Math.pow(2.0*(1-rand),1.0/(MUM+1));

                        val = val+add;

                        if(val>userInput_.maxVals.get(j))
                            val = userInput_.maxVals.get(j);
                        else if(val<userInput_.minVals.get(j))
                            val = userInput_.minVals.get(j);

                        temp.replaceVal(j, val); 
                    }
    //                ObjectiveFunction.definition(diverse);
                    //temp.setObjectiveFunctionVars();
                    offspring.set(i, temp);
                }  
            }catch(Exception e){
                e.printStackTrace();
            }
        }
    }
    
    private void mutationSwap(Chromosome ch){
        if(ch.getValsCopy().size()<2){
            return;
        }
        ArrayList<Integer> randVal; // = MyRandom.randperm(0, ch.getValsCopy().size()-1);
        ArrayList<Double> vals = new ArrayList<Double>();
        double val0, val1;
        int lowIdx, hiIdx;
        double maxSwap = 0.05*ch.getValsCopy().size();
        
        
        for (int i = 0; i < maxSwap; i++) {
            randVal = MyRandom.randperm(0, ch.getValsCopy().size()-1);
            
            lowIdx = randVal.get(0);
            hiIdx = randVal.get(1);

            if(lowIdx > hiIdx){
                lowIdx = randVal.get(1);
                hiIdx = randVal.get(0);
            }

            val0 = ch.getVals(lowIdx);
            val1 = ch.getVals(hiIdx);
            
            vals.add(val0);
            vals.add(val1);

            try {
                ch.remove(lowIdx);
                ch.remove(hiIdx-1);
                //ch.appendVal(val1);
                //ch.appendVal(val0);
            } catch (Exception e) {
                e.printStackTrace();    
                System.out.println("uffff... yeh ulfat..");

            }   
        }
        
        for (Double v : vals) {
            ch.appendVal(v);
        }
        

    }
    
    private void mutationGroupSwap(Chromosome ch){
        ArrayList<Integer> randVal = MyRandom.randperm(0, ch.getSatisfaction().size()-1);
        int Idx0, Idx1;
        int loc;
        ArrayList<ArrayList<Integer>> temp = new ArrayList<ArrayList<Integer>>();
        final int sz = ch.getSatisfaction().size();
        
        if(Math.random()<0.1){
            loc = MyRandom.randperm(0, sz -1).get(0);
            
            for (int i = 0; i < sz; i++) {
                temp.add(ch.getSatisfaction().get(i));
            }
            
            for (int i = 0; i < sz; i++) {
                ch.getSatisfaction().set(i,temp.get((i+loc)%sz));
            }
           
        }else{
            Idx0 = randVal.get(0);
            Idx1 = randVal.get(1);

            ArrayList<Double> list0 = ch.getSatisfaction().get(Idx0);
            ArrayList<Double> list1 = ch.getSatisfaction().get(Idx1);



            ch.getSatisfaction().set(Idx0, list1);
            ch.getSatisfaction().set(Idx1, list0);
        }

        ch.refreshValVsConstIdx();       
        ch.refreshFitness();        
    }
    
    /**
     * METHOD IS NOT TESTED. TEST IT FIRST BEFORE USE.
     * mutationInteger only mutate integers. It uses swap elements technique. 
     * so that it disrupts order more to get new allel values<br>
     * <B>Note:</B> that offspring ArrayList is updated here but rank will remain
     * same because swapping satisfaction value will produce same result. It may
     * only give different results in crossover.
     * @param offspring offspring generated after crossover.
     */
    private void mutationInteger(ArrayList<Chromosome> offspring){
        ArrayList<Integer> randDim;
        ArrayList<Integer> randVal;
        Double temp = 0.0;
        int muteBits;
        
        //System.out.println("testing... " + offspring);

        if(userInput_.domainVals == null || userInput_.domainVals.isEmpty()){ //mutation not supported
            return;
        }

        if(externalData_ == null){ //currently works only for external data
            return;
        }
        
        //Technique 1: swapping values
        //<<
//        for (int ofsp = 0; ofsp < offspring.size(); ofsp++) {            
//            if(Math.random()<1.0/offspring.get(ofsp).getValsCopy().size()){
//                //Only deal with valid values...
//                randDim = MyRandom.randperm(0, offspring.get(ofsp).getRankComponents().size()-1);                
//                
//                if(randDim.size()<2){ //swapping not possible
//                    continue;
//                }else{
//                    holdVals = (ArrayList<Double>)offspring.get(ofsp).getValsCopy().clone();
//                    holdVals.set(randDim.get(0), offspring.get(ofsp).getValsCopy(randDim.get(1)));
//                    holdVals.set(randDim.get(1), offspring.get(ofsp).getValsCopy(randDim.get(0)));                    
//                    offspring.get(ofsp).setVals(holdVals);                    
//                }
//            }
//        }
        //>>
        
        
        ArrayList<Double> vals;
        //ArrayList<Double> noGoods; 
        int expectedVal;
        
        
        
        //Technique 2: mutate a given value from available domain value;
        //<<
//        for (int ofsp = 0; ofsp < offspring.size(); ofsp++) {  
        for (Chromosome offsp : offspring) {                    
            if(Math.random()<MUTATION_RATE){ //1.0/userInput_.totalDecisionVars){ //>1.0/offspring.get(ofsp).getValsCopy().size() || bStagnant){
                               
                vals = offsp.getValsCopy();
                Collections.sort(vals);
                expectedVal = 0;
//                noGoods = new ArrayList<Double>();
//
//                for (int i = 0; i < vals.size(); i++) {                        
//                    if(vals.get(i).intValue() != expectedVal){
//                        for (int j =expectedVal; j < vals.get(i).intValue(); j++) {
//                            noGoods.add(j*1.0); 
//                        } 
//                        expectedVal = vals.get(i).intValue();
//                    } 
//                    expectedVal++;
//                }
//
//                for (int i = vals.get(vals.size()-1).intValue()+1; i < userInput_.totalDecisionVars; i++) {
//                    noGoods.add(i*1.0); 
//                }
                vals.clear();
                if(offsp.noGood.isEmpty()){
                    continue; //nothing to replace with
                }
                
                if(offsp.getValsCopy().size()<2){ //swapping not possible
                    continue;
                }else{
                    if(userInput_.domainVals == null){
                        continue;
                    }else if(userInput_.domainVals.isEmpty()){
                        continue;
                    }
                    
                    muteBits = 1;
                    if(bStagnant){
                        muteBits = Math.max(1,(int)(offsp.getValsCopy().size()*0.2));
                    }
                    //randVal = MyRandom.randperm(0,offsp.noGood.size()-1);
                    
                    for (int j = 0; j < muteBits && j<offsp.noGood.size(); j++) {
                        
                        randVal = MyRandom.randperm(0,offsp.noGood.size()-1);
                        
                        if(bStagnant){ //Important... must refresh in every iteration....
                            muteBits = Math.max(1,(int)(offsp.getValsCopy().size()*0.2));
                        }

                        //Only deal with valid values...
                        randDim = MyRandom.randperm(0, offsp.getValsCopy().size()-1);
                        
                        if(randDim.get(0) >= offsp.getValsCopy().size()){
                            System.out.println("ee kaisey sake...");
                            System.out.println(vals);
                        }
                        try{
//                            randVal = MyRandom.randperm(0,userInput_.domainVals.get(randDim.get(0)).size()-1);
//                            randVal = MyRandom.randperm(0,noGoods.size()-1);
                            if(!externalData_.isHighlyConstrained(offsp.getVals(randDim.get(0)).intValue())) //in optimization mode noGood is empty so automatically this won't be executed.
                                offsp.replaceVal(randDim.get(0),offsp.noGood.get(randVal.get(0)));

//                            int prevVal =  vals.get(randDim.get(0)).intValue();
//                            for (int k = 0; k < userInput_.domainVals.get(prevVal).size(); k++) {
//                                temp = userInput_.domainVals.get(prevVal).get(randVal.get(k));
//                                if(vals.get(randDim.get(0)) != temp){                                
//                                    offspring.get(ofsp).replaceVal(randDim.get(0), temp);//Be warned! may create duplicate values..
//                                    break;
//                                }   
//                            }
                        
                        }catch(Exception e){
                            e.printStackTrace();
                            System.out.println("arey??");
                        }
                        
                    }
                             
                }
            }
        }
        //>>
    }

    private void sortAndReplace(int gen) throws Exception, SolutionFoundException{
        if (userInput_.dataType.contains("Integer")){
            noViolationSortAndReplace(gen); //duplicateSatisfactionSortAndReplace();
//                    xxx(gen);
        }else if (userInput_.dataType.contains("Double")){
            noViolationSortAndReplace(gen);
        }
        else{    
            throw new Exception("Incorrect use of data types");
        }
    }
 
    private void randomDeath(int gen, int spareSize){
        int d;
        ArrayList<Chromosome> newRandPop = new ArrayList<Chromosome>();
        d = (int)Math.round(this.REPLACE_PERCENT*userInput_.population);
        
        try {
            initializeChromosomes(newRandPop, d, gen);  
        } catch (Exception e) {
            e.printStackTrace();
            Application.getInstance().exit();
        }


        //hey??????????? its not a random............. bluffffffffff
//        for (int ofsp = 0; ofsp < d; ofsp++) {  //spare the top d chromes          
//            chromosomes_.set(userInput_.population-1-ofsp, newRandPop.get(ofsp));
//        }
        int temp = 0;
        Chromosome ch;
        for(int i: MyRandom.randperm(spareSize, chromosomes_.size()-1).subList(0, d)){
//        for(int ofsp = 0; ofsp<d; ofsp++){            
            suspended_.add(chromosomes_.get(i));
            if(gen<5)
                chromosomes_.set(i,newRandPop.get(temp++));
            else{    
                ch = suspended_.remove();
                ch.refreshFitness();
                chromosomes_.set(i,ch);                
            }
        }        
    }
    
    
//    private void noViolationSortAndReplace(int gen) throws Exception{
//        ArrayList<Chromosome> diverse = new ArrayList<Chromosome>();
//        ArrayList<Chromosome> newRandPop = new ArrayList<Chromosome>();
//        Chromosome chrome;
//        double maxAcceptedFitness;
//        int safePointer = -1;
//        int d;
//
//
//        for (Chromosome chromosome : chromosomes_) {
//            chromosome.tempSortBy = Chromosome.BY_FITNESS;
//        }
//        
//        Collections.sort(chromosomes_);//sorted according to violation
//        
//        bestSoFar = chromosomes_.get(0);
//        
//        for (Chromosome chromosome : chromosomes_) {
//            if(chromosome.isSolution()){
//                throw new SolutionFoundException("All constraints satisfied");
//            }
//        }
//
//
//        int tempSize;
//        ArrayList<Double> tempVals;
//
//        bStagnant = false;
//        if(gen>userInput_.generation*0.05 && gen%10 == 0){
//            bStagnant = true;
//            System.diverse.println("*** diverse -- removed...");
//            tempSize = (int)(1*SAME_BEST_VAL_PERCENT*userInput_.population);        
//            
//            for (int ofsp= 0; ofsp < tempSize; ofsp++) {
//                tempVals = chromosomes_.get(ofsp).negateVals();
//                chromosomes_.get(ofsp).setVals(tempVals);
//            }            
//            
//            Collections.sort(chromosomes_);          
//        }
//
//        maxAcceptedFitness = chromosomes_.get(userInput_.population-1).getFitnessVal(0);
//
//        try{                       
//            for (Chromosome chromosome : chromosomes_) {
//                if(MyMath.roundN(chromosome.getFitnessVal(0),2) == MyMath.roundN(maxAcceptedFitness,2)){
//                    chrome = (Chromosome)chromosome;
//                    chrome.tempSortBy = userInput_.solutionBy ;
//                    chrome.tempRo = getRoValue(chromosome);
//                    diverse.add(chrome); //exract chromosomes with max accepted violations.
//                }else if(MyMath.roundN(chromosome.getFitnessVal(0),2) < MyMath.roundN(maxAcceptedFitness,2)){
//                    safePointer++;
//                }else{
//                    break;
//                }
//            }
//            chromosomes_ = new ArrayList<Chromosome>(chromosomes_.subList(0, safePointer+1));//not get only required sorted ones.
//
//            for (Chromosome chromosome : diverse) {
//                chromosome.tempSortBy = Chromosome.BY_RO; //MUST DO before sorting
//            }
//            Collections.sort(diverse);
//            for (Chromosome chromosome : diverse) {
//                chromosome.tempSortBy = Chromosome.BY_FITNESS; //MUST DO before sorting
//            }
//
//            chromosomes_.addAll(diverse.subList(0, userInput_.population-safePointer-1));
//
//            if(chromosomes_.size() != userInput_.population){
//                System.err.println("population size error on noViolationSortAndReplace.");
//                Application.getInstance().exit();
//            }
//            
//            for (Chromosome c : chromosomes_) {
//                c.tempSortBy = userInput_.solutionBy;
//            }
//
//            randomDeath();
//        }catch(MyException me){
//            me.showMessageBox();
//        }
//        catch(Exception e){
//            throw e;
//        }
//    }        
    
    private boolean forceFindSolution(Chromosome chrom){                
        ArrayList<Double> vals = chrom.getValsCopy();
        ArrayList<Double> noGoods = new ArrayList<Double>();
       
        Collections.sort(vals);
        int expectedVal = 0;
        
        for (int i = 0; i < vals.size(); i++) {                        
            if(vals.get(i).intValue() != expectedVal){
                for (int j =expectedVal; j < vals.get(i).intValue(); j++) {
                    noGoods.add(j*1.0); 
                } 
                expectedVal = vals.get(i).intValue();
            } 
            expectedVal++;
        }
        
        for (int i = vals.get(vals.size()-1).intValue()+1; i < userInput_.totalDecisionVars; i++) {
            noGoods.add(i*1.0); 
        }

        int prevLength;
        int newLenght=-1;
        Double removedVal;
        
        try{                    
            for (Double ng : noGoods) {               
                prevLength = chrom.getValsCopy().size();
                for (int i = 0; i < chrom.getValsCopy().size(); i++) {
                    removedVal = chrom.getVals(i);
                    if(externalData_.isViolated(removedVal.intValue(), ng.intValue()) && !externalData_.isHighlyConstrained(removedVal.intValue())){
                        chrom.replaceVal(i, ng);
                        chrom.appendVal(removedVal);
                    }
                    newLenght = chrom.getValsCopy().size();

                    if(newLenght>prevLength){//successful addition
                        break;
                    }
                    if(newLenght<prevLength){//successful addition
                        System.out.println("keee kaisey sake?????");
                    }
                    
                }            
            }
        }catch(Exception e){
            e.printStackTrace();
        }
        
        if(newLenght == userInput_.totalDecisionVars){
            return true;
        }else{
            return false;
        }
        
    }
    
    
    private void xxx(int gen) throws Exception{
        for (Chromosome chromosome : chromosomes_) {
            chromosome.tempRo = getRoValue(chromosome);
            chromosome.tempSortBy = userInput_.solutionBy ;//Chromosome.BY_VIOLATIONS; //MUST DO before sorting
        }
        
        Collections.sort(chromosomes_);//sorted according to violation/satisfactions
        
        bestSoFar = chromosomes_.get(0);
        curBest_ = bestSoFar.getRank();
        
        for (Chromosome chromosome : chromosomes_) {        
            if(chromosome.isSolution()){
                bestSoFar = chromosome;
                bestSoFar.tempSortBy = userInput_.solutionBy;
                throw new SolutionFoundException("All constraints satisfied");
            }
            chromosome.tempSortBy = Chromosome.BY_RO;    
        }

        Collections.sort(chromosomes_);  
        chromosomes_ = new ArrayList<Chromosome>(chromosomes_.subList(0, userInput_.population));
        
        for (Chromosome chromosome : chromosomes_) {
            chromosome.tempSortBy = userInput_.solutionBy ;//Chromosome.BY_VIOLATIONS; //MUST DO before sorting
        }
    }
    
    
    private void setUniqueChromosomes(){
        for (int i = 0; i < chromosomes_.size()-1; i++) {
            for (int j = i+1; j < chromosomes_.size(); j++) {
                if(chromosomes_.get(i).equals(chromosomes_.get(j))){
                    chromosomes_.remove(j);
                    j--;
                }
            }
        }
    }
    
    
     /**
     * Sort based on violation preference. select the best ones and then use
     * ro values if same violation is found. Only retrieve predefined size population
     * and discard rest.
     * @throws Exception
     */
    private void noViolationSortAndReplace(int gen) throws Exception{
        ArrayList<Chromosome> diverse = new ArrayList<Chromosome>();
        ArrayList<Chromosome> immune = new ArrayList<Chromosome>();
        ArrayList<Chromosome> goodOnes = new ArrayList<Chromosome>();
        ArrayList<Integer> swapNoGoodIdx = new ArrayList<Integer>();
        ArrayList<Chromosome> tmp = new ArrayList<Chromosome>();
        final int topRepairs = (int)(1*SAME_BEST_VAL_PERCENT*userInput_.population);
        int immuneSize = (int)Math.min(1.5*topRepairs, 0.1*userInput_.population);
        
        Chromosome chrome;
        double maxAcceptedViolation;
        int safePointer = -1;
        int d;                
        
        for (Chromosome chromosome : chromosomes_) {
            //chromosome.refreshFitness();
            chromosome.tempRo = getRoValue(chromosome);
            chromosome.tempSortBy = userInput_.solutionBy ;//Chromosome.BY_VIOLATIONS; //MUST DO before sorting
        }
        
        Collections.sort(chromosomes_);//sorted according to violation/satisfactions
        
        if(chromosomes_.get(0).getRank()<bestSoFar.getRank()){
            bestSoFar = chromosomes_.get(0);
            bestSoFar.tempSortBy = userInput_.solutionBy;
            curBest_ = bestSoFar.getRank();
        }
        
        
        
//        int maxImmunity = externalData_.immunitySize;
//        for (Chromosome chromosome : chromosomes_) {
//            if(chromosome.getParitalSolImmunity()>maxImmunity){
//                maxImmunity = chromosome.getParitalSolImmunity();
//            }
//            if(chromosome.isSolution()){
//                bestSoFar = chromosome;
//                bestSoFar.tempSortBy = userInput_.solutionBy;
//                throw new SolutionFoundException("All constraints satisfied");
//            }
//        }
//        externalData_.immunitySize = maxImmunity;
//        System.out.println("externalData_.immunitySize: " + externalData_.immunitySize);
        
        
        
        if(prevBest_ == curBest_){
            stillSameBestCount++;
        }else{
            stillSameBestCount = 0;
        }   
        
//////        int immuneSize = (int)Math.min(1.5*topRepairs, 0.1*userInput_.population);
//////                
//////        if(externalData_ != null){
//////            for (int ofsp = 0; ofsp < chromosomes_.size(); ofsp++) {
//////                if(chromosomes_.get(ofsp).hasPartialSolImmunity(bestSoFar)){
//////                    if(ofsp<immuneSize){
//////                        immuneSize--; //its already in good chrome
//////                        continue;
//////                    }
//////                    
//////                    immune.add(chromosomes_.get(ofsp));
//////                    chromosomes_.remove(ofsp);
//////                    ofsp--;
//////                    if(immune.size()>= immuneSize){
//////                        break;
//////                    }
//////                }
//////                
//////            }            
//////        }



        try{                                                 
            int goodPop = (int)(0.4*userInput_.population);
                    
            if(bOptimizationMode){
                goodPop = (int)(0.75*userInput_.population); //100%
                immuneSize = (int)(0.15*userInput_.population); //100%
            }
            
            goodOnes.addAll(chromosomes_.subList(0, goodPop));            
            for (int i = 0; i < goodPop; i++) {
                chromosomes_.remove(0);                
            }
            
            for (Chromosome chromosome : chromosomes_) {
                chromosome.tempSortBy = Chromosome.BY_SATISFACTIONS; //MUST DO before sorting
            }
            Collections.sort(chromosomes_);   
            
            //test using for COP...
            
//            for (int i = 0; i < chromosomes_.size(); i++) {
//                if(chromosomes_.get(i).isSolution()){
//                    chromosomes_.remove(i);
//                    i--;
//                }                
//            }
            
            immune.addAll(chromosomes_.subList(0, immuneSize)); //assumes... has immunity...
            for (int i = 0; i < immuneSize; i++) {
                chromosomes_.remove(0);                
            }            
            
            for (Chromosome chromosome : chromosomes_) {                
                chromosome.tempSortBy = Chromosome.BY_RO; //MUST DO before sorting
            }
            
            Collections.sort(chromosomes_);             
            diverse.addAll(chromosomes_.subList(0, userInput_.population-goodPop-immune.size())); 
            for (int i = 0; i < diverse.size(); i++) {
                chromosomes_.remove(0);                
            }                  
            
     
            
            
//            for (int i = 0; i < goodOnes.size(); i+=goodOnes.size()*0.10) { //top 10%
            for (int i = 0; i < goodOnes.size()*0.10; i++) {
                tmp.add(goodOnes.get(i));
                goodOnes.get(i).rmvIndicator = true;
            }
          
            
//            for (int i = 0; i < immune.size(); i+= 1){ //immune.size()*0.50) {
            for (int i = 0; i < immune.size()*0.50; i++){
                tmp.add(immune.get(i));
                immune.get(i).rmvIndicator = true;
            }
            
            
//            for (int i = 0; i < diverse.size(); i+= diverse.size()*0.10) {
            for (int i = 0; i < diverse.size()*0.10; i++) {
                tmp.add(diverse.get(i));
                diverse.get(i).rmvIndicator =  true;
            }
            
            
            for (int i = 0; i < goodOnes.size(); i++) {
                if(goodOnes.get(i).rmvIndicator){
                    goodOnes.remove(i);
                    i--;
                }
            }
            for (int i = 0; i < immune.size(); i++) {
                if(immune.get(i).rmvIndicator){
                    immune.remove(i);
                    i--;
                }
            }
            for (int i = 0; i < diverse.size(); i++) {
                if(diverse.get(i).rmvIndicator){
                    diverse.remove(i);
                    i--;
                }
            }
            
            chromosomes_.clear();
            for (int i = 0; i < tmp.size(); i++) {
                chromosomes_.add((Chromosome)tmp.get(i).clone());                
            }
            
            chromosomes_.addAll(goodOnes);
            chromosomes_.addAll(immune);//not get only required sorted ones.
            chromosomes_.addAll(diverse);            
            
            int im = 0;
            while(chromosomes_.size() != userInput_.population){
                if(chromosomes_.size()>userInput_.population){
                    chromosomes_ = new ArrayList<Chromosome>(chromosomes_.subList(0, userInput_.population));
                }else if(chromosomes_.size()<userInput_.population){
                    chromosomes_.add((Chromosome)diverse.get(im).clone());
                }
            }

            for (Chromosome chromosome : chromosomes_) {
                chromosome.rmvIndicator = false;
                chromosome.tempSortBy = userInput_.solutionBy;
//                chromosome.refreshFitness();
            }
            
            
            randomDeath(gen, tmp.size()); 
            
            
            if(stagnantVisit >= 2){
                stillSameBestCount = 0;
                bStagnant = false;
                stagnantVisit = 0;
            }
            
            
            //if(gen>userInput_.generation*0.05 && gen%10 == 0){
            if((gen == userInput_.generation-1) || 
            (stillSameBestCount >= SAME_BEST_GENERATIONS)){// && externalData_.getCurPref()>= externalData_.maxPref())){
                //stillSameBestCount = 0;
                if(stagnantVisit == 0 && !bOptimizationMode) {//only in first visit.
                    externalData_.pStartIncrement();
                    for (Chromosome chromosome : chromosomes_) {
                        chromosome.refreshFitness();
                    }
                }
                stagnantVisit++;
                bStagnant = true;
                System.out.println("*** temp -- removed...");
               
                
                //Repair process...                
               // if(externalData_.getpStart() >= externalData_.maxPref() || gen >= 0.8*userInput_.generation){
                
                for (Chromosome chrom : tmp){//chromosomes_.subList(0, tmp.size())) {  
                    chrom.tempSortBy = userInput_.solutionBy;
                    chrom.rmvIndicator = false; 
                    if(!chrom.isSolution()){
                        //chrom.forceFindSolution();
                        forceFindSolution(chrom);
                    }else{
                        chrom.setVals(chrom.getNegVals());                             
                    }
                    if(chrom.isSolution() && !bestSoFar.isSolution()){
                        bestSoFar = chrom;
                        bestSoFar.tempSortBy = userInput_.solutionBy;
//                            throw new SolutionFoundException("found at last....");
                    }
                }
                    
                Chromosome chm;
                for (int i = 0; i < tmp.size(); i++) {
                    chm = tmp.get(i); 
                    chromosomes_.add(i,chm);
                    chromosomes_.remove(chromosomes_.size()-1);
                }                         
            }
            
//            ?????????????? 
            if(gen>1 && !bestSoFar.isSolution()){
                externalData_.pStartIncrement();
                 for (Chromosome chrom : chromosomes_) {
                     if(chrom.hasPartialSolImmunity(bestSoFar)){
                         //chrom.forceFindSolution();
                        forceFindSolution(chrom); //This can cause global pStart to remain unchanged (0 or 1) with initial values
                                                //while the beweighted can be changed to true.... 
                     }
                }
            }
            
                    
            
            for (Chromosome ch : chromosomes_) {
                if(ch.isSolution() && !bOptimizationMode){
                    bestSoFar = ch;
                    bOptimizationMode = true;
                    //<<use this..............
                    this.userInput_.bWeighted = true;
                    if(externalData_ != null){
                        externalData_.setCurPref(Integer.MAX_VALUE-1);
                    }
                    //>>........................
                    
                    
                    //<< or this ..........................
//                    this.userInput_.bWeighted = false;
//                    externalData_.bConsiderLength = true;
//                    while(externalData_.getpStart() !=0){
//                        externalData_.pStartDecrement();
//                    }
                    //>> .................................
                    
                    //this.MUTATION_RATE = 0.4;//?????
                    System.out.println("\n\n\n<The system running in Optimization mode>\n\n\n");
                    
                    for (Chromosome newc : chromosomes_) {                        
                        newc.refreshFitness();
                    }
                    
                    for (Chromosome rep : suspended_) {                        
                        rep.refreshFitness();
                    }
                    
                    break;
                }
            }
              
            
            prevBest_ = curBest_;
//            chromosomes_.set(chromosomes_.size()-1, (Chromosome)bestSoFar.clone());
            
//        }catch(MyException me){
//            me.showMessageBox();
        }catch(Exception e){
            //System.out.println(chromosomes_);            
            throw e;
        }
        
                        
       bestSoFar.rmvIndicator = false;
       bestSoFar.tempSortBy = userInput_.solutionBy;

    }
  
    
// <editor-fold defaultstate="collapsed" desc="Old commented code. May be useful :)">    
    
//////    /**
//////     * Sort based on violation preference. select the best ones and then use
//////     * ro values if same violation is found.
//////     * @throws Exception
//////     */
//////    private void noViolationSortAndReplace(int gen) throws Exception, SolutionFoundException{
//////        ArrayList<Chromosome> diverse = new ArrayList<Chromosome>();
//////        ArrayList<Chromosome> newRandPop = new ArrayList<Chromosome>();
//////        Chromosome chrome;
//////        int maxAcceptedViolation;
//////        int safePointer = -1;
//////        int d;
//////
//////        //Get immunity chromosomes...
//////        
//////        
////////        ArrayList<Chromosome> goodImmuneChrom = new ArrayList<Chromosome>();        
////////        for (Chromosome chromosome : chromosomes_) {
////////            chromosome.sortBy = Chromosome.BY_IMMUNITY;        
////////        }
////////        Collections.sort(chromosomes_);        
////////        goodImmuneChrom = new ArrayList<Chromosome>(chromosomes_.subList(0, (int)Math.round(this.IMMUNITY_PERCENT*userInput_.population)));
////////        chromosomes_.removeAll(goodImmuneChrom);
//////        
//////        for (Chromosome chromosome : chromosomes_) {
//////            chromosome.sortBy = userInput_.solutionBy ;//Chromosome.BY_VIOLATIONS; //MUST DO before sorting 
//////            if(chromosome.isSolution()){
//////                throw new SolutionFoundException("All constraints satisfied");
//////            }
//////        }
//////                        
//////        Collections.sort(chromosomes_);//sorted according to violation
//////        bestSoFar = chromosomes_.get(0);
//////
//////        int immuneCount = 0;
////////        Chromosome tempChrome;
////////        
////////        chromosomes_.addAll(0, goodImmuneChrom);
////////        immuneCount = goodImmuneChrom.size();
////////        for (Chromosome chromosome : chromosomes_) {
////////            chromosome.sortBy = userInput_.solutionBy ;//Chromosome.BY_VIOLATIONS; //MUST DO before sorting 
////////        }
////////           
////////        for (Chromosome chromosome : chromosomes_) {
////////            if(chromosome.isSolution()){
////////                throw new SolutionFoundException("All constraints satisfied");
////////            }
////////        }
////////        
////////        for (int ofsp = 0; ofsp < chromosomes_.size(); ofsp++) {
////////            if(chromosomes_.get(ofsp).getImmunity() > 0){
////////                chromosomes_.get(ofsp).useImmunity();
////////                tempChrome = chromosomes_.remove(ofsp);
////////                chromosomes_.add(0, tempChrome);
////////                immuneCount++;
////////            }
////////            
////////            if(immuneCount>= (int)Math.round(this.IMMUNITY_PERCENT*userInput_.population))
////////                break;            
////////        }
//////    
//////        int tempSize;
//////        ArrayList<Double> tempVals;
//////
//////        bStagnant = false;
//////        if(gen>userInput_.generation*0.05 && gen%10 == 0){
//////            bStagnant = true;
//////            System.diverse.println("*** diverse -- removed...");
//////            tempSize = (int)(1*SAME_BEST_VAL_PERCENT*userInput_.population);
//////
//////            for (int ofsp= 0; ofsp < tempSize; ofsp++) {
//////                tempVals = chromosomes_.get(ofsp).negateVals();
//////                chromosomes_.get(ofsp).setVals(tempVals);
//////            }
//////            Collections.sort(chromosomes_);        
//////        }
//////
//////        maxAcceptedViolation = chromosomes_.get(userInput_.population-1).getRank();
//////
//////        try{  
//////            safePointer = immuneCount-1;
//////            for (int ofsp = immuneCount; ofsp < chromosomes_.size(); ofsp++) {
//////                if(chromosomes_.get(ofsp).getRank()==maxAcceptedViolation){
//////                    chrome = (Chromosome)chromosomes_.get(ofsp);
//////                    chrome.tempRo = getRoValue(chromosomes_.get(ofsp));
//////                    diverse.add(chrome); //exract chromosomes with max accepted violations.
//////                }else if(chromosomes_.get(ofsp).getRank() < maxAcceptedViolation){
//////                    safePointer++;
//////                }else{
//////                    break;
//////                }
//////            }            
//////            
//////            chromosomes_ = new ArrayList<Chromosome>(chromosomes_.subList(0, safePointer+1));//not get only required sorted ones.
//////
//////            for (Chromosome chromosome : diverse) {
//////                chromosome.sortBy = Chromosome.BY_RO; //MUST DO before sorting
//////            }
//////            Collections.sort(diverse);
//////            for (Chromosome chromosome : diverse) {
//////                chromosome.sortBy = userInput_.solutionBy; //MUST DO before sorting
//////            }
//////
//////            chromosomes_.addAll(diverse.subList(0, userInput_.population-safePointer-1));
//////
//////            if(chromosomes_.size() != userInput_.population){
//////                System.err.println("population size error on noViolationSortAndReplace.");
//////                Application.getInstance().exit();
//////            }
//////
//////            randomDeath();
//////        }catch(MyException me){
//////            me.showMessageBox();
//////        }
//////        catch(Exception e){
//////            throw e;
//////        }
//////    }

//////    private void getNovelty(Chromosome chromosome, ArrayList<Chromosome> archive){
//////        ArrayList<Chromosome> entirePopulation = new ArrayList<Chromosome>();
//////        ArrayList<Double> diverse = new ArrayList<Double>();
//////
//////        double distSqrMean = 0;
//////        double roMin;
//////
//////        entirePopulation.addAll(archive);
//////        entirePopulation.addAll(chromosomes_);
//////
//////        double[] mean = new double[entirePopulation.size()];
//////
//////        if (archive.size()<ARCHIVE_MAX){
//////            //get mean
//////            for (int ofsp = 0; ofsp < userInput_.totalDecisionVars; ofsp++) {
//////                diverse.clear();
//////                for (int k = 0; k < entirePopulation.size(); k++) {
//////                    diverse.add(entirePopulation.get(k).vals.get(ofsp));
//////                }
//////                mean[ofsp] = MyMath.mean(diverse);
//////            }
//////
//////            //now get variance - actually ofsp amusing average mean square distane
//////            for (int ofsp = 0; ofsp < entirePopulation.size(); ofsp++) {
//////                distSqrMean += Math.pow(MyMath.norm(entirePopulation.get(ofsp).vals, diverse),2);
//////            }
//////            distSqrMean = distSqrMean/entirePopulation.size();
////////            roMin  = distSqrMean;
//////            roMin = 0;
//////        }
//////        else{
//////
//////        }
//////    }


    
    
    
    
    
//////    /**
//////     * Seems working 
//////     * 
//////     */
//////    private void duplicateSatisfactionSortAndReplace(){
//////        Chromosome tempChrome;
//////        ArrayList<Double> tempVals;
//////        int newSize;
//////        int tempSize;
//////        ArrayList<Integer> randIdx;
//////
//////        for (Chromosome chromosome : chromosomes_) {
//////            chromosome.sortBy = userInput_.solutionBy; //MUST DO before sorting
//////        }
////////        for (Chromosome chromosome : chromosomes_) {
////////            chromosome.sortBy = Chromosome.BY_RO; //MUST DO before sorting
////////            try{
////////            chromosome.tempRo = getRoValue(chromosome);
////////            }catch (Exception e){
////////                e.printStackTrace();
////////            }
////////        }
//////        
//////        bStagnant = false;
//////        if(isStagnant()){
//////            Collections.sort(chromosomes_);
//////            bStagnant = true;
//////            System.diverse.println("*** diverse -- removed...");
//////            tempSize = (int)(3*SAME_BEST_VAL_PERCENT*userInput_.population);
//////
//////            
//////            for (int ofsp= 0; ofsp < tempSize; ofsp++) {
//////                //chromosomes_.remove(0);        
//////                tempVals = chromosomes_.get(ofsp).negateVals();                
//////                chromosomes_.get(ofsp).setVals(tempVals);
//////            }
//////            
////////            try{
////////                //System.diverse.println("be " + chromosomes_.get(0).getValsCopy());
////////                mutation(new ArrayList<Chromosome>(chromosomes_.subList(0, tempSize)));
////////            }catch(UnsupportedDataTypeException udte){
////////                System.diverse.println(udte.getLocalizedMessage());
////////                Application.getInstance().exit();
////////            }
//////        }
//////
//////       
//////        ArrayList<Chromosome> newRandPop = new ArrayList<Chromosome>();
//////
//////
//////
//////         
//////        if(chromosomes_.size() < userInput_.population){            
//////            newSize = userInput_.population-chromosomes_.size();
//////            //randomly make copy of existing chromosomes...
//////            //randIdx = MyRandom.randperm(0, chromosomes_.size()-1);
//////
//////            try {
//////                initializeChromosomes(newRandPop, newSize);
//////            } catch (Exception e) {
//////                e.printStackTrace();
//////                Application.getInstance().exit();
//////            }
//////            
//////            for (int ofsp = 0; ofsp < newSize; ofsp++) {
//////                chromosomes_.addAll(newRandPop);
//////            }
//////
//////            Collections.sort(chromosomes_);
//////            
//////        }else{            
//////            Collections.sort(chromosomes_);
//////            
//////            for (int ofsp = chromosomes_.size()-1; ofsp >= 0; ofsp--) {
//////                if(chromosomes_.size() == userInput_.population)
//////                    break;
//////
//////                tempChrome = chromosomes_.get(ofsp);            
//////                for (Chromosome chromosome : chromosomes_) {
//////                    //NOTE THIS STEP .... you can use the commented one as well.....
//////                    //if(chromosome != childChrome && chromosome.getRankComponents().containsAll(childChrome.getRankComponents())){
//////                    if(chromosome != tempChrome && chromosome.getValsCopy().containsAll(tempChrome.getValsCopy())){
//////                        chromosomes_.remove(ofsp);                    
//////                        break;
//////                    }
//////                }
//////            }
//////
//////            if(chromosomes_.size() > userInput_.population){ //still more...
//////                chromosomes_ = new ArrayList<Chromosome>(chromosomes_.subList(0, userInput_.population));//pick best ones.
//////            }
//////        }
////////        int d;
////////        ArrayList<Chromosome> newRandPop = new ArrayList<Chromosome>();
////////        d = (int)Math.round(this.REPLACE_PERCENT*userInput_.population);
////////        
////////        try {
////////            initializeChromosomes(newRandPop, d);  
////////        } catch (Exception e) {
////////            e.printStackTrace();
////////            Application.getInstance().exit();
////////        }
////////
////////        for (int ofsp = 0; ofsp < d; ofsp++) {
////////            chromosomes_.set(userInput_.population-1-ofsp, newRandPop.get(ofsp));
////////        } 
//////            randomDeath();
//////    }
    
// </editor-fold>    
     
} //End of class definition
